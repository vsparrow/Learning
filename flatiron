GIT  ****************************************************************
git cheet sheet                     https://www.git-tower.com/blog/content/posts/54-git-cheat-sheet/git-cheat-sheet-large01.png
git add .                           to add your local changes to be committed.
git clone                           to clone a repository to your local computer.
                                        To clone, make sure you've clicked on the SSH link (it starts with git@github.com:
git commit -am "Commit Message"     to commit changes that have been added with a message.
git push                            to upload your local changes to GitHub.
git reset --hard <commit id>        revert
git status                          to see the status of your locally cloned git repository.

GITHUB FORK                         Forking is the process of making a personal copy of the Learn lab on GitHub
github pull request(web)            Submitting a pull request is how you submit your lab to be evaluated or graded 


RUBY *****************************************************************
ARGUMENTS
              calling methods with parentheses, e.g., greeting('Sophie'). 
                But you can also omit the parentheses: greeting 'Sophie'.
  default/optional    (name = "Ruby programmer"), we simply assign the argument name a default value of "Ruby programmer" 
  required+optional   def greeting(name, language="Ruby") # required MUST come before optional
  SPLAT       
    splat   *, can be used to convert an array into a list of arguments
             def add(a,b) ;  a + b ;  end  ; pair = [3,7] ;  add *pair #here pair is sent in as 3 and 7 not [3,7]
    multiple assignments
            first, *list = [1,2,3,4]          # first= 1, list= [2,3,4]
            *list, last  = [1,2,3,4]          # list= [1,2,3], last= 4
            first, *center, last = [1,2,3,4]  # first= 1, center= [2,3], last=4

            a = *"Hello"  #=> ["Hello"]  #usues array coersion. see below cannot use .to_a so use this
            "Hello".to_a  #=> NoMethodError: undefined method `to_a' for "Hello":String
            a = *(1..3)   #=> [1, 2, 3]
            a = *[1,2,3]  #=> [1, 2, 3]  


DEBUGGING
  pry          gem install pry
               require "pry" on top of code 
               use the following line "binding.pry" anywhere in your code.
                When the interpreter hits that line, your program will actually freeze and your terminal 
                  will turn into a REPL(interpreter like irb)
  .to_stdout   method works by temporarily replacing the $stdout variable.                   

FILES  
  !           "shebang line" and it tells the shell which interpreter to use to execute the remainder of the file.
                #!/usr/bin/env ruby  Any executable files we place in our bin directory need to begin with the line
                you can execute your program by typing bin/< your file name > into the command line, 
                  since the shebang line at the top of your executable file is already telling the shell to use Ruby 
                  

LOOPS
  .each       see Types.Array.each
  for         for counter in 1..40 do   /n    puts "The current number is #{counter}."  /nend
              shoe_count = 1..32 /n for shoe in shoe_count /n  puts "I'm putting a pair of shoes away."  /n   end
  loop        simple example
                counter = 0 # Start our counter at 0, we have never run the loop
                loop do # Start our loop
                  counter = counter + 1
                  puts "Iteration #{counter} of the loop"
                  if counter >= 10 # If our counter is 10 or more
                    break # Stop the loop
                  end
                end                
  num.times    5.times do     /n    puts "Penguins like to jump off icebergs!" /n end                 
  while       while counter < 20   /n   puts "The current number is less than 20." /n  counter += 1 end
  until       until counter == 20 /n  puts "The current number is less than 20." /n  counter += 1 end
  
METHODS
  block           a simple form of a closure in Ruby. Blocks are constructed with a do...end or with {}.
  block_given?    method to optionally take block           if block_given? X else Y end
  closure         block of functional code with variables that are bound to the environment that the closure is called in.
                    it can be passed around like an object 
                    can be defined in one scope and be called in a completely different scope,
                    it remembers the variables within its scope at the time of creation; 
                      when it's called, it can access those variables even if they might not be in that current scope
  helper          smaller methods, each of which is responsible for one discrete unit of the game.
  lambda          isn't that much different than a proc in functionality. The & before it turns it into a block,
                   plus_one = lambda { |n| puts n + 1 }; array = [1, 2, 3] ; array.each(&plus_one)
                   ALTERNATE decleration :: plus_one = ->(n) { puts n + 1 }
                  Proc vs Lambda 
                    lambdas check for arguments ; procs just returns nil for the missing argument, but do not throw an error                    they return differently: lambdas return to the calling method and 
                      procs return immediately without going back to the caller—essentially,
                      lambdas behave more like method calls: you can think of them as anonymous functions
                    flow control differences proc vs lambda : the return and break keyword  are treated is the difference 
                      return from proc returns from wrapping method, lamnda woud just continue
                        see https://www.skorks.com/2010/05/ruby-procs-and-lambdas-and-the-difference-between-them/
  proc            is a block turned into an object by being assigned to an instance of the Proc class.
                    Procs are a type of closure , can be assigned to a local variable,
                    is executed by calling the call method on it,  more than one proc can be passed to a method. 
                    greeting = Proc.new { "Hello!" } ; greeting.call => "Hello!"
                  see also lambda
  wrapper/runner  a boss method 
                    ex To run our program, we need to call several  methods. 
                    Instead of calling each of them in turn, we might place them inside a single method. 
                    Then, to enact our program, we only have to invoke our one wrapper, or runner method
  yield           Stop executing the code in this method, and instead execute the code in this block. 
                    Then, return to the code in the method."  
                  if give it an argument, it will pass that argument to the block and 
                    that data will become available to the code in the block.  
                  https://learn.co/tracks/web-development-fundamentals/intro-to-ruby/enumerables/yield-and-blocks
                  
OPERATORS/OPERATIONS

TYPES
  Array
  range       see below 
  .any?       return true if the code in the block evaluates to true for any element in the collection. 
  .collect    see .map
  .delete     Deletes items from self that are equal to obj. If any items are found, returns obj.
  .delete_at  Deletes the element at the specified index, returning that element,  
  .delete_if  delete from the collection any items that return true for a certain condition:
  .each       iterate over array CHANGES ARRAY!  see .map for non change
  .each_with_index    interate with an index included
  find        see .index()    
  .first
  .flatten    Returns a new array that is a one-dimensional flattening of this array (recursively) [1,[2,3]] => [1,2,3]
  .INCLUDE?   does contain?
  .index()    argument inside the parentheses will return the first index number of an element matching that argument.
                famous_cats.index("Puss in Boots") => 1    # famous_cats = ["Cheshire Cat", "Puss in Boots", "Garfield"]
                see .select for ALL the elements
  .insert     letters.insert(-1, 'd')   #insert d into last position   
  .inspect    returns a string containing a human-readable representation of an object.
  .last
  .map        similar to .each except a new array or hash object is returned, not the original one.
  .pop(2)     can use pop to remove more than one item!!!!!!!!
  .sample     get a random value from array
  .select     returns a new collection containing of  elements in the submitted collection for which
                the block's conditional is true
  .shift(2)   can shift more than one item!!!
  .size       like .length
  .sort       return new array. use sort! to affect current arr
                "spaceship operator" (<=>). The spaceship operator, also called the combined comparison operator
                array.sort do |a, b| /n   a <=> b    /n end; a==b return 0; a<b return -1; a>b return 1
  .reverse
  .uniq       remove duplicate items
  other enumberables    http://ruby-doc.org/core-2.2.2/Enumerable.html
  

  Bool        0 1   true false
    truthy    only nil and false are falsey.   0 is "truthy"
    double-bang operator 
              (!!) will return true or false based on whether a value is truthy or falsey to begin with.

  Hash
        See also SYMBOLS below
        store objects differ from arrays in that they function like dictionaries. 
        hashes are composed of key/value pairs. Each key points to a specific value
          ––just like a word and a definition in a regular dictionary.
          {"i'm a key" => "i'm a value!", "key2" => "value2"}
        Hashes allow us to store named, or associated, data. Think of a dictionary or an address book.  
    =>       symbol, known for this use as the "hash-rocket" (because it looks like a little rocket               
    adding   hashes use the "bracket-equals" method to add data. #hash["new_key"] = "New Value"
              person = { "name" => "Corinna",  "age" => 36} ; person["hometown"] = "Massena, NY"


  Numbers   
          Fixnums are whole numbers, like 7.
          Floats are decimal numbers, like 7.3.
  .ceil     7.5.ceil  => 8
  .floor    7.5.floor   => this method will round the float down to the nearest fixnum. Here it will return 7
   MAth     http://ruby-doc.org/core-2.2.0/Math.html  
              functions like sqrt
  .next     10.next => 11
  
  Range     a set of values with a beginning and an end. A range can contain strings or integers.
            A range of strings: ("a", "b", "c", "d") A range of integers: (1, 2, 3, 4, 5, 6, 7, 8, 9, 10)
            A range can be constructed using this notation: (100..200) Or this notation: (100...200)
            .. ("double-dot") includes the second number (200) in the range, while using a ... ("triple-dot") excludes it.
            Ranges can be helpful when you are generating arrays which we will be learning more about soon.
    .to_a   method, when called on a range, can convert a range of numbers to an array:
              (1..10).to_a   => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
  
  Strings
   array      a = *"Hello"  #=> ["Hello"]  # see RUBY ARGUMENTS SPLAT for more   
  .class      get class of any item.    "hello".class
  .join
  .reverse    "hello".reverse    => "olleh"
  .size       "hello".size    => 5
  .split
  .start_with?  
  .swapcase   "hELLO".swapcase  => "Hello"
  .upcase     "hello".upcase  => "HELLO"

  Symbol
            symbol is a representation of a piece of data. Symbols look like this :my_symbol. 
            If I make a symbol, :my_symbol, and then use that symbol later on in my code,
                my program will refer to the same area of memory in both cases.
    two wats to write
              flatiron_school = {:instructor => "Isaac Newton"}
              flatiron_school = {instructor: "Isaac Newton"}   *****recommend ********
    assign data
              flatiron_school = {   instructors: ["Avi", "Jeff", "Rose"]}  
              instructors = flatiron_school[:instructors]  # => ["Avi", "Jeff", "Rose"]  
    iterate using each
              hash.each do |key, value| /n   puts "#{key}: #{value}" /n end
    .KEYS     returns an array containing all of the keys in the hash that .keys              
    .MIN      return the key/value pair that contains that lowest key, either alphabetically or numerically:
    .to_s     method on a symbol to convert it into a string
    .VALUES   You can collect all of the values in a hash with the .values method:          
    RUBY DOCS http://ruby-doc.org/core-2.2.2/Hash.html

VARIABLES   variables   words or characters that hold values
            don’t hold object values. str doesn’t contain “Hello”. Rather, str contains a reference to a string object. 
              It’s the string object that has the characteristic of containing the letters that make up “Hello”.
  constant    written in UPPERCASE or Capitalized. They have a global scope when defined globally, 
                and local scope when defined within classes and modules. 
                Constants cannot be defined within methods. When constants are initialized, they should not be reassigned.               
                cannot start with a number, be a Ruby reserved word, or have punctuation or space characters.
  Global variables  "global scope". accessed anywhere in a program and are declared with a dollar sign in front   
                      $global_variable
  Local variables   "local scope", meaning that their definitions remain where they are declared.
                      If we define a variable within a method definition, only the method knows about that variable                
  pass-by-value  A variable makes a copy of the value it holds and passes the copy over to something else that 
                  alters or changes it.   
                  ex "hello".upcase
                  Primitive data like integers, floats, fixnums, and symbols require a fixed, small amount of memory. 
                    therefor pass by value                    
  pass-by-reference. changes to a variable would alter what is stored in the actual location it refers to.
                After the process was complete the variable would be holding a new and different value.
                ex x=5                
                 Objects that can grow and change, like arrays and strings, are never a fixed size. 
                  They are instead always accessed by a reference pointer
  range       see RUBY->TYPES
  type        the type of the value a var holds. Ruby is what is known as a dynamically typed language. 
                means the value of a variable can change its type and does not need to be explicitly/permanently defined. 



RSPEC ***************************************************************
  A test is always going to be about setting up a state with a known result and 
  comparing that known result or expectation to the behavior of your program, 
  thus ensuring that your program behaves as you expected.  

ERROR TYPES
  ARGUMENT ERRORS   occur when methods are passed either too few or too many arguments.
  NAME ERRORS       NameErrors are caused when a given name is invalid or undefined
  NO METHOD ERRORS  no method for something
                      will often occur when you have a variable set to nil
  Syntax errors     they're the result of incorrect syntax.
  TYPEERRORS        When you try and do a mathematical operation on two objects of a different type,


Structure
  require_relative '../a.rb'  #loads the code from our actual program file 
  describe "something" do     #we use the describe RSpec method and strings to describe what we are testing. 
                  This code is entirely for you, the programmer, and has very little meaning to RSpec or Ruby.
  it "returns something" do   #to state an expectation or behavior of that method.       
      "" is only there to provide you, the programmer, with a description of what behavior we're currently testing.
      #what is inside the "it do end" block is what we actually test      
  expect(age_of_person).to eq(19)   #expect var to equal value
  Stubbing        refers to the fake implementation of a method.

SHELL ***************************************************************
commands    see https://www.gnu.org/software/bash/manual/html_node/Bash-Builtins.html
LS
    ls -lah        h is a suffix on the l flag meaning "human readable formats." 
                    a meaning "all information including permissions".
    la -a          show jidden files                
loop    for f in *.txt;do echo $f;done    
open  it will trigger the default action associated with the file type. $ open hello_world.rb
paths
  absolute path 
    points to the same location  regardless of the working directory. They start with / ("forward slash") 
    because that is the root of your file system. This is an absolute path: /Users/avi.
  relative path 
    path relative to the working directory of the user or application, 
    They start with the name of a directory or a file.This is a relative path: avi/Documents.
$PATH  list of directories that BASH will look in for commands, scripts, and programs.  type into shell
    edit .bash_profile to add/remove dirs
pipe    | symbol named "pipe", will send the output of one command into the input of another command.    
        $ ps aux | grep ruby
ps aux  get all processes
pwd   print working dir , get current dir
~     go home dir  , tilda

    





SQL *****************************************************************
SQL statements terminated with a ";"
open db   sqlite3 test_sqlite.db
datatypes: TEXT INTEGER REAL(is float/decimal) BLOB

CREATE TABLE table_name;  
  create a database table called "Test Table" create table test_table(id);    
  CREATE TABLE cats (
        id INTEGER PRIMARY KEY,
                name TEXT, 
                age INTEGER
            );
  create from file:   sqlite3 pets_database.db < 01_create_cats_table.sql

show tables   .tables
show scema    .schema
change table(schema)  ALTER TABLE cats ADD COLUMN breed TEXT;
  change from file    sqlite3 pets_database.db < 02_add_column_to_cats.sql.
change data (table)     INSERT INTO cats (name, age, breed) VALUES ('Maru', 3, 'Scottish Fold');
                        we don't have to specify the id column values when we insert data. Primary Key columns are auto-incrementing. 
  change data from file   sqlite3 pets_database.db < 01_insert_cats_into_cats_table.sql
format output         
                      .header on       # output the name of each column
                      .mode column     # now we are in column mode, enabling us to run the next two .width commands
                      .width auto      # adjusts and normalizes column width
                      # or
                      .width NUM1, NUM2 # customize column width
  different colname   alias or AS
                      SELECT AVG(net_worth) AS average_net_worth FROM cats;
  group_by            aggregate function GROUP BY
                        SELECT breed, COUNT(breed) FROM cats GROUP BY breed;
    multiple column     SELECT breed, owner_id, COUNT(breed) FROM cats GROUP BY breed, owner_id; 
    

  order_by            ORDER BY. This modifier allows us to order the table rows returned by a certain SELECT statement.
                        SELECT column_name FROM table_name ORDER BY column_name ASC|DESC;
                          sqlite> SELECT * FROM cats ORDER BY age;
                          
  limit               LIMIT is used to determine the number of records you want to return from a dataset
                        SELECT * FROM cats ORDER BY age DESC LIMIT 1;   returns just the first, i.e. oldest, cat on the list.
  between             SELECT column_name(s) FROM table_name WHERE column_name BETWEEN value1 AND value2;
                        SELECT name FROM cats WHERE age BETWEEN 1 AND 3;  


select data           SELECT [names of columns we are going to select] FROM [table we are selecting from];
                        SELECT id, name, age, breed FROM cats;
                        SELECT * FROM cats;
  select unique data    SELECT DISTINCT name FROM cats;
  select on condition   SELECT * FROM [table name] WHERE [column name] = [some value];
                          SELECT * FROM cats WHERE name = "Maru";
                          SELECT * FROM cats WHERE age < 2;
                          SELECT COUNT(*) FROM cats WHERE net_worth > 1000000;

  aggregate functions   functions perform a calculation on specified values, queried from a database table.                        
    select count        the number of records that meet certain condition      
                         "SELECT COUNT([column name]) FROM [table name] WHERE [column name] = [value]"
                          SELECT COUNT(owner_id) FROM cats WHERE owner_id = 1;
    select avverage     SELECT AVG(column_name) FROM table_name;
                        SELECT AVG(net_worth) FROM cats;
    select sum          SELECT SUM(column_name) FROM table_name;
                        SELECT SUM(net_worth) FROM cats;
    select minmax       SELECT MIN(column_name) FROM table_name;
                        SELECT MAX(column_name) FROM table_name;
                      
  select from 2 tables in db
                        SELECT cats.name, dogs.name FROM cats, dogs; must use tablename infront of column name


  see also "format output" section                        
update data           UPDATE [table name] SET [column name] = [new value] WHERE [column name] = [value];
                        UPDATE cats SET name = "Hana" WHERE name = "Hannah";
  null                add data with missing values using the NULL keyword.
                        INSERT INTO cats (name, age, breed) VALUES (NULL, NULL, "Tabby");
                        SELECT * FROM cats WHERE name IS NULL;


                          



                      

                        


delete table  DROP TABLE cats;

help  .help            
quit  .quit




YAML ********************************************************************************************
YAML        is used because it is easier for humans to read and write than typing out entire arrays, hashes, etc.
  ex
  commands  require 'yaml' # STEP ONE, REQUIRE YAML!
            # Parse a YAML string
            YAML.load("--- foo") #=> "foo"

            # Emit some YAML
            YAML.dump("foo")     # => "--- foo\n...\n"
            { :a => 'b'}.to_yaml  # => "---\n:a: b\n"
  
  ARRAY     All members of a list are lines beginning at the same indentation level starting with a "- " (a dash and a space):
            # fruits.yml
              - Apple
              - Orange
              - Strawberry
              - Mango
            # ruby file
            require "yaml" 
            fruits = YAML.load_file('fruits.yml')
            fruits             # => ["Apple","Orange","Strawberry","Mango"]
            
            OPTIONAL:: inline format ->  # Shopping list  /n  [milk, pumpkin pie, eggs, juice]
  HASH      # thisisahash.yml
            garfield: Orange
            tom: gray
            #ruby file
            require "yaml"
            cat = YAML.load_file('thisisahash.yml')
            cat # => # { "garfied" => "orange", "tom" => "gray"}
            
             --- # Indented Block
               name: John Smith
               age: 33
             --- # Inline Block
             {name: John Smith, age: 33}
  STRINGS   two ways to write multi-line strings, 
                one preserving newlines (using the | character) 
                one that folds the newlines (using the > character), both followed by a newline character.
  further reading     http://docs.ansible.com/ansible/latest/YAMLSyntax.html
                      http://www.ruby-doc.org/stdlib-1.9.3/libdoc/yaml/rdoc/YAML.html
  
