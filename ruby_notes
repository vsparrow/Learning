ruby .rb files

Addition (+)
Subtraction (-)
Multiplication (*)
Division (/)
Exponentiation (**)
Modulo (%)

puts adds a newline to the end of the output. print does not.  

.. vs ... # ..creates an inclusive range, while ... creates a range that excludes the specified high value.

###STRING ###STRING ###STRING ###STRING ###STRING ###STRING ###STRING ###STRING 
#---------------------------------------------------------------------------------------
"string".length #get length of string ie: 5
"string".reverse #get reverse of string, ie: gnirts
"string".upcase #convert string to upper case ie: STRING
"String".downcase #convert to lowercase, ie: "string"
"strinG".capitalize #Uppercase first char, lowercase other chars ie: "String"
"strinG".captitalize! # ! modifies variable so that its permanantly set
if user_input.include? "s"   # finds char "s" and replaces it with "th"
    user_input.gsub!(/s/,"th")
string.include? "s" #evaluates to true if it finds "s" and false otherwise.
string.gsub!(/s/,"th") # global substitution method, here substitute all "s" for "th"
string.split(",") #  takes string returns array. use text in parentheses as  delimiter
number.to_s # takes number converts to string

comments:
# for single line comments
for multiline comments see below: anything inbetween commented out. open and close must be in all on own, nothing else can be added
=begin
=end

#variables  #variables #variables #variables #variables #variables #variables #variables #variables #variables 
#------------------------------------------------------------------------------------------------------------
convention #variables start with lowercase letter and words should be separated by underscores, like counter and masterful_method
variable_y = gets.chomp #assign variable to user input, Ruby adds newline after each bit of input; chomp removes that extra line. 
#{variable_y}  #use variable in print : print "Your input of #{variable_y} is cool" 
variable_y =Integer(user.chomp) # the variable HAS to be an int
item1 <=> item 2 # combined comparison operator  compare two Ruby objects.  returns 0 if the first operand (item to be compared) equals the second, 1 if first operand is greater than the second, and -1 if the first operand is less than the second

#arrays #arrays #arrays #arrays #arrays #arrays #arrays #arrays #arrays #arrays 
#-----------------------------------------------------------------------------
my_array=[1,2,3,4,5]    # Array
my_array.sort           # will sort array
books.sort! { |firstBook, secondBook| firstBook <=> secondBook } ## To sort our books in ascending order, in-place , default
books.sort! {|book1,book2| book2 <=> book1} ## Sort your books in descending order, in-place below
my_array.reverse!       #reverse sort
s.each { |x|  x.each {|y| puts "#{y}" }}   #print out each item of multi-demensional array


#hash #hash #hash #hash #hash #hash #hash #hash #hash #hash #hash #hash #hash #hash 
#---------------------------------------------------------------------------------
# hashes are just collections of key-value pairs, where a unique key is associated with some value.
# keys must be unique, but values can repeat. (That's why we can have more than one key share the value "cat."
# create hash : hash literal notation       :   new_hash = { "one" => 1 }
# create hash : hash constructor notation   :   new_hash = Hash.new
my_hash=Hash.new            # same as my_hash={}
my_has["Stevie"] = "cat"    # add a hash : if print my_hash["Stevie"] output is "cat"

colors = colors.sort_by do |color, count| # sort from smallest to largest by count. sort_by function returns an array of arrays
    count
end
colors = colors.sort_by { |color, count| count} #same as above


my_hash = { "name" => "Eric",  #hash is a collection of key-value pairs. 
  "age" => 26,
  "hungry?" => false
} 
my_hash.each {|x,y| "puts #{x}:#{y}" }  # will print name:Eric  age:26  hungry:false
frequencies=Hash.new(0) # The first time we find the word, it will have a default value of 0 



#Expression #Expression #Expression #Expression #Expression #Expression #Expression #Expression #Expression #Expression #Expression 
#--------------------------------------------------------------------------------

if expression   # if statments always finsih with an "end" statement
  dosomething #The block of code following an if should be indented two spaces. formatting a should not a must
elsif expression2
  dosomething2
else
  dosomething3
end

unless  some_false_variable    #continue if not true expression; its like "if not true" ; same syntax as if
  doexpression
end

problem = false
print "Good to go!" unless problem
Remember, this is basically a short hand if statement. It will do whatever you ask unless the condition is true. 
In our example, problem is false, so we don't have a problem. We print Good to go!

boolean: # 3 operators && ||  !


# LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS 
# ---------------------------------------------------------------------------------------------------------

until some_statement_is_true
  do this
end

loop do
    something
end

for i in 1..3
    print i
end

30.times do |x|
    print "Ruby!"
end

letters = ['a', 'b', 'c', 'd']
letters.each do |letter|
  print letter
end


object.each { |item| # Do something } # between | |  anything, placeholder for each element of the object "each" used on.
object.each do |item| # Do something end 
2.times {puts "COOL"} # .times method compact for loop:  perform  task on each item in an object a specified number of times.

break if i > 5 # when in loop will break if i > 5
next if i % 2 == 0  #in loop skip to next iteration if state true, ie: if even number go to next iteration


#function #function #function #function #function #function #function #function #function #function #function #function #function #function 
#----------------------------------------------------------------------------------------------------------------------
#argument: piece of code you actually put between the method's parentheses when you call it  Here its 12
#parameter: parameter is the name you put between the method's parentheses when you define it. parameter here is n 
#splat arguments. Splat arguments are arguments preceded by a *, which signals to Ruby: "Hey Ruby, I don't know how many arguments there are about to be, but it could be more than one."
#blocks think of blocks as a way of creating methods that don't have a name. (These are similar to anonymous functions in JavaScript or lambdas in Python.)

1.times do
  puts "I'm a code block!"
end
1.times { puts "As am I!" }
