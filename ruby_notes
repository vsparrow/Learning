ruby .rb files

Addition (+)
Subtraction (-)
Multiplication (*)
Division (/)
Exponentiation (**)
Modulo (%)
[1.2,2.2].floor # [1,2] method rounds a float (a number with a decimal) down to the nearest integer. 


puts adds a newline to the end of the output. print does not.  

.. vs ... # ..creates an inclusive range, while ... creates a range that excludes the specified high value.


 CRUD, for create, read, update, and delete (respectively). These are the actions you take when you update an entry in a database, ask a website for information, or write a blog post. 

returns: Ruby's methods will return the result of the last evaluated expression if return not defined


###STRING ###STRING ###STRING ###STRING ###STRING ###STRING ###STRING ###STRING 
#---------------------------------------------------------------------------------------
"string".length #get length of string ie: 5
"string".reverse #get reverse of string, ie: gnirts
"string".upcase #convert string to upper case ie: STRING
"String".downcase #convert to lowercase, ie: "string"
"strinG".capitalize #Uppercase first char, lowercase other chars ie: "String"
"strinG".captitalize! # ! modifies variable so that its permanantly set
if user_input.include? "s"   # finds char "s" and replaces it with "th"
    user_input.gsub!(/s/,"th")
string.include? "s" #evaluates to true if it finds "s" and false otherwise.
string.gsub!(/s/,"th") # global substitution method, here substitute all "s" for "th"
string.split(",") #  takes string returns array. use text in parentheses as  delimiter
number.to_s # takes number converts to string
"I love " + "drink" # becomes " I love drink"
"I love " << drink # same as above, here if drink is variable = chai, "I love chai"


comments:
# for single line comments
for multiline comments see below: anything inbetween commented out. open and close must be in all on own, nothing else can be added
=begin
=end

#variables  #variables #variables #variables #variables #variables #variables #variables #variables #variables 
#------------------------------------------------------------------------------------------------------------
convention #variables start with lowercase letter and words should be separated by underscores, like counter and masterful_method
variable_y = gets.chomp #assign variable to user input, Ruby adds newline after each bit of input; chomp removes that extra line. 
#{variable_y}  #use variable in print : print "Your input of #{variable_y} is cool" 
variable_y =Integer(user.chomp) # the variable HAS to be an int
item1 <=> item 2 # combined comparison operator  compare two Ruby objects.  returns 0 if the first operand (item to be compared) equals the second, 1 if first operand is greater than the second, and -1 if the first operand is less than the second
puts "string".object_id #  .object_id method gets the ID of an objectâ€”it's how Ruby knows whether two objects are the exact same object

#arrays #arrays #arrays #arrays #arrays #arrays #arrays #arrays #arrays #arrays 
#-----------------------------------------------------------------------------
my_array=[1,2,3,4,5]    # Array
my_array.sort           # will sort array
books.sort! { |firstBook, secondBook| firstBook <=> secondBook } ## To sort our books in ascending order, in-place , default
books.sort! {|book1,book2| book2 <=> book1} ## Sort your books in descending order, in-place below
my_array.reverse!       #reverse sort
s.each { |x|  x.each {|y| puts "#{y}" }}   #print out each item of multi-demensional array
my_array.collect { |num| num ** 2 } # return 2 4 9 16 25 : takes code block and applies the expression in the block to every element in an array. 

#hash #hash #hash #hash #hash #hash #hash #hash #hash #hash #hash #hash #hash #hash 
#---------------------------------------------------------------------------------
# hashes are just collections of key-value pairs, where a unique key is associated with some value.
# keys must be unique, but values can repeat. (That's why we can have more than one key share the value "cat."
# create hash : hash literal notation       :   new_hash = { "one" => 1 }
# create hash : hash constructor notation   :   new_hash = Hash.new
my_hash=Hash.new            # same as my_hash={}
my_has["Stevie"] = "cat"    # add a hash : if print my_hash["Stevie"] output is "cat"
no_nil_hash=Hash.new(0) # The first time we find the word, it will have a default value of 0 rather than default of nil


colors = colors.sort_by do |color, count| # sort from smallest to largest by count. sort_by function returns an array of arrays
    count
end
colors = colors.sort_by { |color, count| count} #same as above


my_hash = { "name" => "Eric",  #hash is a collection of key-value pairs. 
  "age" => 26,
  "hungry?" => false
} 
my_hash.each {|x,y| "puts #{x}:#{y}" }  # will print name:Eric  age:26  hungry:false



#Expression #Expression #Expression #Expression #Expression #Expression #Expression #Expression #Expression #Expression #Expression 
#--------------------------------------------------------------------------------

if expression   # if statments always finsih with an "end" statement
  dosomething #The block of code following an if should be indented two spaces. formatting a should not a must
elsif expression2
  dosomething2
else
  dosomething3
end

#one line if
puts "It's true!" if true # BUT CANNOT DO THIS -> if true puts "It's true!"

#ternary conditional expression
boolean ? Do this if true: Do this if false #example: puts 3 < 4 ? "3 is less than 4!" : "3 is not less than 4."


unless  some_false_variable    #continue if not true expression; its like "if not true" ; same syntax as if
  doexpression
end

problem = false
print "Good to go!" unless problem
Remember, this is basically a short hand if statement. It will do whatever you ask unless the condition is true. 
In our example, problem is false, so we don't have a problem. We print Good to go!

boolean: # 3 operators && ||  !


#CASE
case language
when "JS"
  puts "Websites!"
else
  puts "I don't know!"
end

#CASE ALTERNATE
case language
  when "JS" then puts "Websites!"
  else puts "I don't know!"
end

#conditional assignment operator: ||=    only want to assign a variable if it hasn't already been assigned? 
favorite_book = nil
favorite_book ||= "Cat's Cradle" #now cats cradle because was before nil
favorite_book ||= "Why's (Poignant) Guide to Ruby" # still cats cradle because favbook NOT nil
favorite_book = "Why's (Poignant) Guide to Ruby" # now wpgtr because of assignment operator







# LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS # LOOPS 
# ---------------------------------------------------------------------------------------------------------

until some_statement_is_true
  do this
end

loop do
    something
end

for i in 1..3
    print i
end

30.times do |x|
    print "Ruby!"
end

letters = ['a', 'b', 'c', 'd']
letters.each do |letter|
  print letter
end


object.each { |item| # Do something } # between | |  anything, placeholder for each element of the object "each" used on.
object.each do |item| # Do something end 
2.times {puts "COOL"} # .times method compact for loop:  perform  task on each item in an object a specified number of times.

break if i > 5 # when in loop will break if i > 5
next if i % 2 == 0  #in loop skip to next iteration if state true, ie: if even number go to next iteration


#function #function #function #function #function #function #function #function #function #function #function #function #function #function 
#----------------------------------------------------------------------------------------------------------------------
#argument: piece of code you actually put between the method's parentheses when you call it  Here its 12
#parameter: parameter is the name you put between the method's parentheses when you define it. parameter here is n 
#splat arguments. Splat arguments are arguments preceded by a *, which signals to Ruby: "Hey Ruby, I don't know how many arguments there are about to be, but it could be more than one."
#blocks think of blocks as a way of creating methods that don't have a name. (These are similar to anonymous functions in JavaScript or lambdas in Python.)

1.times do
  puts "I'm a code block!"
end
1.times { puts "As am I!" }


#symbols #symbols #symbols #symbols #symbols #symbols #symbols #symbols #symbols #symbols #symbols #symbols 
#--------------------------------------------------------------------------------------------------------
primarily used either as hash keys or for referencing method names. 
Symbols make good hash keys for a few reasons:
    They're immutable, meaning they can't be changed once they're created;
    Only one copy of any symbol exists at a given time, so they save memory;
    Symbol-as-keys are faster than strings-as-keys because of the above two reasons.
.to_s #convert between strings and symbols The .to_s and .to_sym methods are what you're looking for!
.to_sym # to symbol
.to_i #to integer
.intern #This will internalize the string into a symbol and works just like .to_sym:
.to_a  # takes range of objects and turns it into array of objects
good_movies = movie_ratings.select {|movie,rating| rating > 3} # select function
.each_key #my_hash.each_key { |k| print k, " " }
.each_value # my_hash.each_value { |v| print v, " " }

add values:
movies.store(title,rating) 
movies[title]=rating

delete values:
movies.delete(title)

#calls #calls  #calls #calls #calls #calls #calls #calls #calls #calls #calls #calls #calls #calls #calls #calls 
#------------------------------------------------------------------------------------------------------------

strings = ["1", "2", "3"]
nums = strings.map(&:to_i)
# ==> [1, 2, 3]
