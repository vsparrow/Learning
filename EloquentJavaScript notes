Chapter1: 
There are six basic types of values in JavaScript: numbers, strings, Booleans, objects, functions, and undefined values.
2.998e8 means 2.998 * 10^8 = 299,900,00  
Infinity and -Infinity, which represent the positive and negative infinities. Infinity - 1 is still Infinity, and so on. 
  Don’t put too much trust in infinity-based computation. It isn’t mathematically solid,  
NaN stands for “not a number”
  You’ll get this when, for example, (0/ 0), or any number of other numeric operations that don’t yield a  meaningful result.
  There is only one value in JavaScript that is not equal to itself, and that is NaN, which stands for “not a number”.
    console.log(NaN == NaN)  // → false
    if you find yourself getting one of those in an unexpected place, look for accidental type conversions.
typeof operator, which produces a string value naming the type of the value you give it.  
  typeof 4.5 => number   typeof "x" => string
unary operators operators that take one value example minus 
  -10
binary operators: operators that take 2 values, example minus
  9-2
  *minus can be binary or unary operator
ternary, operating on three values.
  console.log(true ? 1 : 2); // → 1   console.log(false ? 1 : 2); // → 2  This one is called the conditional operator
undefined vs null is an accident of JavaScript’s design, and it doesn’t matter most of the time. 
false
  0, NaN, and the empty string ("") count as false, while all the other values count as true. 
  Because of this, expressions like 0 == false and "" == false are also true. 
Type conversions  
  For cases where you do not want any automatic type conversions to happen, there are two extra operators: === and !==.
  
Chapter2:
variables   imagine variables as tentacles, rather than boxes. They do not contain values; they grasp them
environment The collection of variables and their values that exist at a given time 
  When a program starts up, this environment is not empty. It always contains variables that are part of the language standard,
function  piece of program wrapped in a value. Such values can be applied in order to run the wrapped program. 
  example, in a browser environment, the variable alert holds a function that shows a little dialog box with a message.
block: A sequence of statements wrapped in braces.  
constructor  the first letter of a variable is capitalized. This was done to mark this function as a constructor 
  ie: Number()
  
Chapter3:
lexical scoping. approach to variable visibility  
  each local scope can also see all the local scopes that contain it.  
scope   in JavaScript, functions are the only things that create a new scope.
  People who have experience with other languages might expect that any block of code between braces produces a new local environment.
  EXAMPLE: the something inside the block refers to the same variable as the one outside the block. 
    var something = 1; {  var something = 2;}
function 
  conceptually moved to the top of their scope and can be used by all the code in that scope
    ie: console.log(root(4)); root(x){return something}  :  even though root decalred after console, still useable
  “var square = function(){}  is the name as function square(){}
  standards: dont put function inside an if block
call stack The place where the computer stores call context 
  function has to jump back to the place of the call when it returns, 
  the computer must remember the context from which the function was called. 
  Every time a function is called, the current context is put on top of this “stack”. 
  When the function returns, it removes the top context from the stack and uses it to continue execution.
  stack requires space in the computer’s memory. When the stack grows too big,
    the computer will fail with a message like “out of stack space” or “too much recursion”.
arguments:
  JavaScript is extremely broad-minded about the number of arguments you pass to a function.
  If you pass too many, the extra ones are ignored.
  If you pass too few, the missing parameters simply get assigned the value undefined.
    The upside is that this behavior can be used to have a function take “optional” arguments.
closure
  being able to reference a specific instance of local variables in an enclosing function—is called closure.
  A function that “closes over” some local variables is called A closure. (ie: it is A closure) 
recursions
  in typical JavaScript implementations, it’s about 10 times slower than the looping version. 
  Running through a simple loop is a lot cheaper than calling a function multiple times.
  why recursion?
    Often, a program deals with such complex concepts that giving up some efficiencyto make the program straightforward is attractive
    
